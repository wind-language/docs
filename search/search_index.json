{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Wind Language Documentation The Future of Programming with Wind Wind is a powerful, lightweight, and efficient programming language designed to give you full control over performance, memory, and execution. Whether you're building low-level systems or high-performance applications, Wind is the language for you. Why Wind? Minimalistic Syntax : Clean and simple syntax that allows you to focus on logic. High Performance : Achieve high performance with low-level control over memory and resources. Easy Integration : Seamlessly integrate with existing codebases and systems. Key Features Low-Level Control : Directly manage memory and resources for optimal performance. Safe from overflows : Prevent integer overflows and memory leaks with built-in safety features. Getting Started Check out the VSCode Extension Wind has a VSCode Extension that provides syntax highlighting and code snippets to help you write Wind code more efficiently. To get started with Wind, follow these steps: Install the Compiler : Installation Guide Hello, World! : Learn how to write your first Wind program with the Quick Start Guide . Compiler Documentation : Dive deeper into how the Wind compiler works with the Compiler Docs . Syntax Reference : Explore the Wind syntax with the Language Reference . Advanced Examples : Check out some advanced examples to see what Wind is capable of. Examples Take a look at some code examples to get a feel for how Wind works: Basic Syntax Example : Learn how to write a simple program. Advanced Performance Example : See how Wind performs in low-level operations. About & Contributing Learn More About Wind Community Join the Wind community and contribute to the language's growth: GitHub Repository Discord Server Support If you run into any issues, check out the Troubleshooting Guide or reach out to the community. Developed with \u2764\ufe0f by utcq","title":"Home"},{"location":"#welcome-to-the-wind-language-documentation","text":"","title":"Welcome to the Wind Language Documentation"},{"location":"#the-future-of-programming-with-wind","text":"Wind is a powerful, lightweight, and efficient programming language designed to give you full control over performance, memory, and execution. Whether you're building low-level systems or high-performance applications, Wind is the language for you.","title":"The Future of Programming with Wind"},{"location":"#why-wind","text":"Minimalistic Syntax : Clean and simple syntax that allows you to focus on logic. High Performance : Achieve high performance with low-level control over memory and resources. Easy Integration : Seamlessly integrate with existing codebases and systems.","title":"Why Wind?"},{"location":"#key-features","text":"Low-Level Control : Directly manage memory and resources for optimal performance. Safe from overflows : Prevent integer overflows and memory leaks with built-in safety features.","title":"Key Features"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#check-out-the-vscode-extension","text":"Wind has a VSCode Extension that provides syntax highlighting and code snippets to help you write Wind code more efficiently. To get started with Wind, follow these steps: Install the Compiler : Installation Guide Hello, World! : Learn how to write your first Wind program with the Quick Start Guide . Compiler Documentation : Dive deeper into how the Wind compiler works with the Compiler Docs . Syntax Reference : Explore the Wind syntax with the Language Reference . Advanced Examples : Check out some advanced examples to see what Wind is capable of.","title":"Check out the VSCode Extension"},{"location":"#examples","text":"Take a look at some code examples to get a feel for how Wind works: Basic Syntax Example : Learn how to write a simple program. Advanced Performance Example : See how Wind performs in low-level operations.","title":"Examples"},{"location":"#about-contributing","text":"Learn More About Wind","title":"About &amp; Contributing"},{"location":"#community","text":"Join the Wind community and contribute to the language's growth: GitHub Repository Discord Server","title":"Community"},{"location":"#support","text":"If you run into any issues, check out the Troubleshooting Guide or reach out to the community. Developed with \u2764\ufe0f by utcq","title":"Support"},{"location":"about/","text":"About Wind & Me Who am I? I am an high school student who loves programming and low-level stuff. I started programming when I was 10 and I have been learning and experimenting with different programming languages and technologies since then. I am passionate about systems programming, compilers, and operating systems. I've been working on Wind for a while now and I'm excited to share it with the world, as I am writing this Wind is still in its early stages and already 200Kb of code. I am working on it every day and I am excited to see where it goes. Why Wind? Wind is a programming language that I created to learn more about compilers and low-level programming. I wanted to build a language that is simple, efficient, and gives full control to the programmer. Wind is designed to be minimalistic, fast, and easy to use while providing modern features and safety guarantees. I believe that Wind has the potential to be a great language for systems programming, embedded development, and high-performance applications. I am excited to see how the community will use Wind and what amazing projects they will build with it. Contributing Wind is an open-source project and I welcome contributions from the community. If you are interested in helping to improve Wind, please check out the GitHub repository and feel free to submit pull requests, report issues, or join the discussion on the Discord server . I am always looking for feedback, suggestions, and ideas to make Wind better. If you have any thoughts or questions about Wind, please don't hesitate to reach out to me. I am excited to hear from you and work together to make Wind the best it can be. Needed Contributions Compiler error reporting : The error reporting in the compiler is not very good, I would like to improve it by adding more detailed error messages and suggestions for how to fix them. The best way to do this would be including a Token in every AST node and then using that token to get the line and column of the error. Documentation : Help improve the Wind documentation by adding examples, tutorials, and guides. Testing : Test Wind on different platforms and report any issues or bugs you encounter. Feature Requests : Share your ideas for new features or improvements to Wind.","title":"About"},{"location":"about/#about-wind-me","text":"","title":"About Wind &amp; Me"},{"location":"about/#who-am-i","text":"I am an high school student who loves programming and low-level stuff. I started programming when I was 10 and I have been learning and experimenting with different programming languages and technologies since then. I am passionate about systems programming, compilers, and operating systems. I've been working on Wind for a while now and I'm excited to share it with the world, as I am writing this Wind is still in its early stages and already 200Kb of code. I am working on it every day and I am excited to see where it goes.","title":"Who am I?"},{"location":"about/#why-wind","text":"Wind is a programming language that I created to learn more about compilers and low-level programming. I wanted to build a language that is simple, efficient, and gives full control to the programmer. Wind is designed to be minimalistic, fast, and easy to use while providing modern features and safety guarantees. I believe that Wind has the potential to be a great language for systems programming, embedded development, and high-performance applications. I am excited to see how the community will use Wind and what amazing projects they will build with it.","title":"Why Wind?"},{"location":"about/#contributing","text":"Wind is an open-source project and I welcome contributions from the community. If you are interested in helping to improve Wind, please check out the GitHub repository and feel free to submit pull requests, report issues, or join the discussion on the Discord server . I am always looking for feedback, suggestions, and ideas to make Wind better. If you have any thoughts or questions about Wind, please don't hesitate to reach out to me. I am excited to hear from you and work together to make Wind the best it can be.","title":"Contributing"},{"location":"about/#needed-contributions","text":"Compiler error reporting : The error reporting in the compiler is not very good, I would like to improve it by adding more detailed error messages and suggestions for how to fix them. The best way to do this would be including a Token in every AST node and then using that token to get the line and column of the error. Documentation : Help improve the Wind documentation by adding examples, tutorials, and guides. Testing : Test Wind on different platforms and report any issues or bugs you encounter. Feature Requests : Share your ideas for new features or improvements to Wind.","title":"Needed Contributions"},{"location":"help/","text":"Troubleshooting ld: cannot find wrt.o: No such file or directory","title":"Troubleshooting"},{"location":"help/#troubleshooting","text":"ld: cannot find wrt.o: No such file or directory","title":"Troubleshooting"},{"location":"learn/advanced/","text":"Wind Advanced Examples Welcome to the Wind advanced examples! Here you'll find a collection of advanced code snippets that demonstrate the power and flexibility of the Wind programming language. These examples cover mainly runtime checks and memory management, showcasing how Wind can help you write safe and efficient code. Table of Contents Memory Management Pointers and References Error Handling Memory Management Here's an example of how you can run read/write data from the user without having to worry about memory leaks, buffer overflows, integer over/underflows or any other memory-related issues. @include[ \"#libc.wi\" ] func main(): int { var buff: [char;32]; __builtin_memset(buff, 0, 32); var user_i: s32; printf(\"name: \"); scanf(\"%s\", buff); printf(\"index: \"); scanf(\"%d\", &user_i); var user_c: char = buff[user_i]; var square: s32 = user_i * user_i; printf(\"buff[%d] = %c ; Squared i = %d\\n\", user_i, user_c, square); return 0; } Protection breakdown scanf(\"%s\", buff) : No input limit? No problem! There's a canary check that will prevent return address overwrites. buff[user_i] : Accessing an array out of bounds? Impossible! There are runtime checks that will prevent out-of-bounds access. user_i * user_i : Integer overflow? Not a chance! Every unsafe arithmetic operation is checked for overflow. Pointers and References Here's an example of how you can use pointers and references in Wind to create safe and efficient code. @include[ \"#libc.wi\" ] func get_ptr(): ptr<int> { var buff: ptr<int> = guard![malloc(32*900000000)]; return buff; } func main(): int { var buff: ptr<int> = get_ptr(); printf(\"Buff: %p\\n\", buff); return 0; } Protection breakdown malloc(32*900000000) : Null pointers? Not here! The guard![] directive will check for null pointers and prevent dereferencing. Error Handling Here's an example of how you can use error handling in Wind to create robust and reliable code. @include[ \"#libc.wi\" ] func main(argc: int, argv: ptr<ptr<char>>): int { var T: s16=30_000; var i: s16=0; loop [true] { printf(\"Enter a number to sum to %d within 16 bits: \", T); scanf(\"%hu\", &i); try { T += i; } [SUM_OF] -> { printf(\"Sum overflowed 16 bits\\n\"); } finally { continue; } break; } printf(\"Sum: %d\\n\", T); return 0; } Protection breakdown T += i : There could be an overflow here, but it will be caught by default. While [SUM_OF] will set the handler code only for the code inside the try block. In absence of a try-catch the program would have called the default runtime handler for arithmetic exceptions.","title":"Wind Advanced Examples"},{"location":"learn/advanced/#wind-advanced-examples","text":"Welcome to the Wind advanced examples! Here you'll find a collection of advanced code snippets that demonstrate the power and flexibility of the Wind programming language. These examples cover mainly runtime checks and memory management, showcasing how Wind can help you write safe and efficient code.","title":"Wind Advanced Examples"},{"location":"learn/advanced/#table-of-contents","text":"Memory Management Pointers and References Error Handling","title":"Table of Contents"},{"location":"learn/advanced/#memory-management","text":"Here's an example of how you can run read/write data from the user without having to worry about memory leaks, buffer overflows, integer over/underflows or any other memory-related issues. @include[ \"#libc.wi\" ] func main(): int { var buff: [char;32]; __builtin_memset(buff, 0, 32); var user_i: s32; printf(\"name: \"); scanf(\"%s\", buff); printf(\"index: \"); scanf(\"%d\", &user_i); var user_c: char = buff[user_i]; var square: s32 = user_i * user_i; printf(\"buff[%d] = %c ; Squared i = %d\\n\", user_i, user_c, square); return 0; }","title":"Memory Management"},{"location":"learn/advanced/#protection-breakdown","text":"scanf(\"%s\", buff) : No input limit? No problem! There's a canary check that will prevent return address overwrites. buff[user_i] : Accessing an array out of bounds? Impossible! There are runtime checks that will prevent out-of-bounds access. user_i * user_i : Integer overflow? Not a chance! Every unsafe arithmetic operation is checked for overflow.","title":"Protection breakdown"},{"location":"learn/advanced/#pointers-and-references","text":"Here's an example of how you can use pointers and references in Wind to create safe and efficient code. @include[ \"#libc.wi\" ] func get_ptr(): ptr<int> { var buff: ptr<int> = guard![malloc(32*900000000)]; return buff; } func main(): int { var buff: ptr<int> = get_ptr(); printf(\"Buff: %p\\n\", buff); return 0; }","title":"Pointers and References"},{"location":"learn/advanced/#protection-breakdown_1","text":"malloc(32*900000000) : Null pointers? Not here! The guard![] directive will check for null pointers and prevent dereferencing.","title":"Protection breakdown"},{"location":"learn/advanced/#error-handling","text":"Here's an example of how you can use error handling in Wind to create robust and reliable code. @include[ \"#libc.wi\" ] func main(argc: int, argv: ptr<ptr<char>>): int { var T: s16=30_000; var i: s16=0; loop [true] { printf(\"Enter a number to sum to %d within 16 bits: \", T); scanf(\"%hu\", &i); try { T += i; } [SUM_OF] -> { printf(\"Sum overflowed 16 bits\\n\"); } finally { continue; } break; } printf(\"Sum: %d\\n\", T); return 0; }","title":"Error Handling"},{"location":"learn/advanced/#protection-breakdown_2","text":"T += i : There could be an overflow here, but it will be caught by default. While [SUM_OF] will set the handler code only for the code inside the try block. In absence of a try-catch the program would have called the default runtime handler for arithmetic exceptions.","title":"Protection breakdown"},{"location":"learn/compiler/","text":"Compiler documentation Welcome to the Wind Language Compiler Documentation! This page will guide you through the internals of the Wind compiler and how it transforms your Wind code into executable programs. Command Line Options The Wind compiler provides a few command-line options to control the compilation process. -o <output> : Specify the output file name for the compiled program. -h : Display the help message with available options. -ej : Compile as an object file without linking. -sa : Output the generated AST in a human-readable format. -si : Output the generated IR in a human-readable format. -ss : Output the generated assembly code. Example Here is an example of compiling a Wind program using the Wind compiler: windc hello.w -ss -o hello This command compiles the hello.w source file, outputs the generated assembly code, and creates an executable named hello . Overview The Wind compiler is a lightweight and efficient tool that translates Wind source code into machine code that can be executed by the target system. It performs several stages of compilation to analyze, optimize, and generate the final executable. The key stages of the Wind compiler include: Lexical Analysis : The source code is broken down into tokens for further processing. Syntax Analysis : The tokens are parsed into an abstract syntax tree (AST) to represent the structure of the program. Compilation : The AST is transformed into an intermediate representation (IR) that can be optimized. Optimization : The IR is optimized to improve performance and reduce resource usage. Code Generation : The optimized IR is translated into assembly code for the target system. Assembly : Via GNU Assembler, the assembly code is converted into machine code that can be executed. Linking : The compiled code is linked with runtime libraries to create the final executable or the object file. Code Generation Currently Wind supports only x86_64 architecture. The generated assembly code is compatible with the x86_64 instruction set and can be executed on systems that support this architecture. The generated assembly code is designed to be efficient and optimized for performance. It leverages the capabilities of the x86_64 architecture to achieve high performance and low resource usage. The assembly is generated by the fully hand-written backend which is designed to be simple and efficient. The backend generates assembly code directly from the IR without the need for an intermediate representation. The assembly into machine code is done by the GNU Assembler ( as ), I have plans to write a custom assembler in the future but executable formats are pretty complex so it's not a priority. Runtime Library The Wind compiler relies on a set of runtime libraries to provide essential functionality to the compiled programs. These libraries include functions for error handling, memory management, and initialization of the program.","title":"Compiler documentation"},{"location":"learn/compiler/#compiler-documentation","text":"Welcome to the Wind Language Compiler Documentation! This page will guide you through the internals of the Wind compiler and how it transforms your Wind code into executable programs.","title":"Compiler documentation"},{"location":"learn/compiler/#command-line-options","text":"The Wind compiler provides a few command-line options to control the compilation process. -o <output> : Specify the output file name for the compiled program. -h : Display the help message with available options. -ej : Compile as an object file without linking. -sa : Output the generated AST in a human-readable format. -si : Output the generated IR in a human-readable format. -ss : Output the generated assembly code.","title":"Command Line Options"},{"location":"learn/compiler/#example","text":"Here is an example of compiling a Wind program using the Wind compiler: windc hello.w -ss -o hello This command compiles the hello.w source file, outputs the generated assembly code, and creates an executable named hello .","title":"Example"},{"location":"learn/compiler/#overview","text":"The Wind compiler is a lightweight and efficient tool that translates Wind source code into machine code that can be executed by the target system. It performs several stages of compilation to analyze, optimize, and generate the final executable. The key stages of the Wind compiler include: Lexical Analysis : The source code is broken down into tokens for further processing. Syntax Analysis : The tokens are parsed into an abstract syntax tree (AST) to represent the structure of the program. Compilation : The AST is transformed into an intermediate representation (IR) that can be optimized. Optimization : The IR is optimized to improve performance and reduce resource usage. Code Generation : The optimized IR is translated into assembly code for the target system. Assembly : Via GNU Assembler, the assembly code is converted into machine code that can be executed. Linking : The compiled code is linked with runtime libraries to create the final executable or the object file.","title":"Overview"},{"location":"learn/compiler/#code-generation","text":"Currently Wind supports only x86_64 architecture. The generated assembly code is compatible with the x86_64 instruction set and can be executed on systems that support this architecture. The generated assembly code is designed to be efficient and optimized for performance. It leverages the capabilities of the x86_64 architecture to achieve high performance and low resource usage. The assembly is generated by the fully hand-written backend which is designed to be simple and efficient. The backend generates assembly code directly from the IR without the need for an intermediate representation. The assembly into machine code is done by the GNU Assembler ( as ), I have plans to write a custom assembler in the future but executable formats are pretty complex so it's not a priority.","title":"Code Generation"},{"location":"learn/compiler/#runtime-library","text":"The Wind compiler relies on a set of runtime libraries to provide essential functionality to the compiled programs. These libraries include functions for error handling, memory management, and initialization of the program.","title":"Runtime Library"},{"location":"learn/install/","text":"Compiler installation Guide Welcome to the Wind Language Installation Guide! This page will walk you through the essential steps to install the Wind compiler on your system. Prerequisites Currently the Wind compiler is only supported on Linux and macOS systems. Before you begin, make sure you have the following: Basic knowledge of programming concepts. A terminal and a text editor. Installer Script curl -L https://wind-lang.me/setup | bash Compiling from source Open your terminal. Clone the Wind repository: git clone https://github.com/utcq/wind cd wind Build the compiler using CMake: mkdir build && cd build cmake .. make Now the wind compiler is installed in build/bin directory as windc . Make sure to keep the source intact for the compiler to work properly. To change runtime and std path you can use CMAKE flags: cmake .. -DWIND_RUNTIME_PATH=/path/to/runtime -DWIND_STD_PATH=/path/to/std","title":"Compiler installation Guide"},{"location":"learn/install/#compiler-installation-guide","text":"Welcome to the Wind Language Installation Guide! This page will walk you through the essential steps to install the Wind compiler on your system.","title":"Compiler installation Guide"},{"location":"learn/install/#prerequisites","text":"Currently the Wind compiler is only supported on Linux and macOS systems. Before you begin, make sure you have the following: Basic knowledge of programming concepts. A terminal and a text editor.","title":"Prerequisites"},{"location":"learn/install/#installer-script","text":"curl -L https://wind-lang.me/setup | bash","title":"Installer Script"},{"location":"learn/install/#compiling-from-source","text":"Open your terminal. Clone the Wind repository: git clone https://github.com/utcq/wind cd wind Build the compiler using CMake: mkdir build && cd build cmake .. make Now the wind compiler is installed in build/bin directory as windc . Make sure to keep the source intact for the compiler to work properly. To change runtime and std path you can use CMAKE flags: cmake .. -DWIND_RUNTIME_PATH=/path/to/runtime -DWIND_STD_PATH=/path/to/std","title":"Compiling from source"},{"location":"learn/quick/","text":"Quick Start Guide Welcome to the Wind Language Quick Start Guide! This page will walk you through the essential steps to get up and running with a \"Hello World\" in Wind in no time. Prerequisites Before you begin, make sure you have the following: A Linux or macOS system. Basic knowledge of programming concepts. A terminal and a text editor. Wind installed on your system. Step 1: Write Your First Program Once Wind is installed, create your first Wind program. Open your favorite text editor and write the following: @include \"#libc.wi\" func main(): int { puts(\"Hello, Wind!\"); return 0; } Save the file as hello.w . Step 2: Compile Your Program In the terminal, navigate to the folder where you saved your program and compile it: windc hello.wind -o hello This will generate an executable file called hello in the same directory. Step 3: Run Your Program To run your program, type: ./hello You should see: Hello, Wind! Congratulations! You\u2019ve just written and executed your first Wind program! Step 4: Need Help? Syntax : Learn more about the syntax of Wind. Advanced Examples : Explore advanced examples to see what Wind is capable of. Troubleshooting : Solutions to common issues you might face. Happy coding with Wind! \ud83c\udf89","title":"Getting Started"},{"location":"learn/quick/#quick-start-guide","text":"Welcome to the Wind Language Quick Start Guide! This page will walk you through the essential steps to get up and running with a \"Hello World\" in Wind in no time.","title":"Quick Start Guide"},{"location":"learn/quick/#prerequisites","text":"Before you begin, make sure you have the following: A Linux or macOS system. Basic knowledge of programming concepts. A terminal and a text editor. Wind installed on your system.","title":"Prerequisites"},{"location":"learn/quick/#step-1-write-your-first-program","text":"Once Wind is installed, create your first Wind program. Open your favorite text editor and write the following: @include \"#libc.wi\" func main(): int { puts(\"Hello, Wind!\"); return 0; } Save the file as hello.w .","title":"Step 1: Write Your First Program"},{"location":"learn/quick/#step-2-compile-your-program","text":"In the terminal, navigate to the folder where you saved your program and compile it: windc hello.wind -o hello This will generate an executable file called hello in the same directory.","title":"Step 2: Compile Your Program"},{"location":"learn/quick/#step-3-run-your-program","text":"To run your program, type: ./hello You should see: Hello, Wind! Congratulations! You\u2019ve just written and executed your first Wind program!","title":"Step 3: Run Your Program"},{"location":"learn/quick/#step-4-need-help","text":"Syntax : Learn more about the syntax of Wind. Advanced Examples : Explore advanced examples to see what Wind is capable of. Troubleshooting : Solutions to common issues you might face. Happy coding with Wind! \ud83c\udf89","title":"Step 4: Need Help?"},{"location":"learn/syntax/","text":"Wind syntax reference Welcome to the Wind Language Syntax Reference! This page will guide you through the syntax of the Wind programming language, including its keywords, operators, and conventions. Comments Comments in Wind are similar to C-style comments and can be single-line or multi-line. // This is a single-line comment /* This is a multi-line comment */ @ Directives Let's break the ice with the @ directives. These are used to include files, define flags, and more. include The include directive is used to include a file in the current file. The file path is relative to the current file. @include \"path/to/file.w\" Using # as the first character of the file path will include a file from the standard library. @include \"#types.wi\" Multi include is also supported. @include [ \"path/to/file1.w\" \"path/to/file2.w\" ] import Pay attention to the import directive. @import \"#my_module\" You can use # prefix here as well to include a module from the WIND_PKGS_PATH . Import searches for a dir like this: name/ name.wi name.w The name.wi file is the interface file, and the name.w file is the implementation file. The interface file should contain the function prototypes, and the implementation file should contain the function definitions. Interface file example: func test_fn(x: int): int; Implementation file example: func test_fn(x: int): int { return x*(x+1); } pure The pure directive is used to define a function flag. @pure[stack expr] func foo() {} stack - Local variables usage won't be optimized. expr - Expressions aren't optimized. logue - No prologue and epilogue will be generated. stchk - No check for stack overflow and integer overflow will be generated. extern The extern directive is used to define a function as an external function. @extern func foo(); pub The pub directive is used to define a function as public. While public directive is not required for including functions, it is used to share functions between objects when linking. @pub func foo() {} type The type directive is used to define a type. @type my_type = unsigned byte; linkflag The linkflag directive is used to define an ld flag. @linkflag(\"-lm); Keywords Wind has no concept of reserved-identifiers, so you can use any keyword as an identifier if you wish. However, the following keywords are used in the language and should be avoided as identifiers: func var global return branch else loop continue break asm true false Null Data Types Wind has some primitive data types: byte = signed 8 bits short = signed 16 bits int = signed 32 bits long = signed 64 bits unsigned byte = unsigned 8 bits ... But the \"#types.wi\" std file provides some more types: s8 = signed 8 bits s16 = signed 16 bits s32 = signed 32 bits s64 = signed 64 bits u8 = unsigned 8 bits s16 = unsigned 16 bits s32 = unsigned 32 bits s64 = unsigned 64 bits bool = 8 bits char = 8 bits Arrays are declared using the following syntax: var arr: [int; 10]; Pointers Pointers are declared using the following syntax: var ptr: ptr<int>; Wind convention is to use heap allocation over stack allocated arrays. with the guard![] directive, you can check for null pointers and prevent dereferencing. var my_ptr: ptr<char> = guard![malloc(32)]; Casting Casting in Wind is done with the as operator. var x: ptr<u64> = malloc(...); (x as ptr<char>)[0]='x'; Sizeof The sizeof<> directive is used to get the (move) size of a type. var size_int: int = sizeof<int>; Variables Variables in Wind are declared using the var keyword, followed by the variable name and type. var x: int = 10; You can declared them in bulk as well. var [x,y,z]: int = 0; Global Variables Global variables are declared using the global keyword. global x: int = 10; Non declarable in bulk. Functions Functions in Wind are declared using the func keyword, followed by the function name, parameters, and return type. func add(x: int, y: int): int { return x + y; } There's no wrapper for variadic functions, but you can still use ... for external C functions. @extern func printf(format: string, ...): int; Namespaces Namespaces in Wind are declared using the namespace keyword. namespace my_namespace { func foo() { puts(\"Hello, World!\"); } } Used with the :: operator. my_namespace::foo(); Control Flow Wind has the usual control flow features with unique syntax. Branch The branch keyword is used to define a conditional statement. branch [ x == 0: puts(\"x is zero\"); else: { puts(\"x != 0); return 1; } ] Loop The loop keyword is used to define a loop statement. loop [x < 10] { puts(\"x is less than 10\"); x++; } There's no for loop in Wind, but you can use the loop keyword with a counter. Continue The continue keyword is used to skip the current iteration of a loop. loop [x < 10] { x++; continue; } Break The break keyword is used to exit a loop. loop [x < 10] { x++; break; } Try Catch Wind has a try-catch implementation for error handling. This is a simple implementation and is not as powerful as other languages. In fact it's just a wrapper to set the handler code for arithmetic exceptions and other security features like guard![] . try { T += 20_000; // sum overflow T = guard![Null]; } [SUM_OF] -> { printf(\"Sum overflow handled\\n\"); } [GUARD] -> { printf(\"Null pointer exception handled\\n\"); } finally { printf(\"Exceptions handled\\n\"); } Exceptions SUM_OF - Arithmetic exceptions. SUB_OF - Arithmetic exceptions. MUL_OF - Arithmetic exceptions. DIV_OF - Arithmetic exceptions. GUARD - Null pointer exceptions. BOUNDS - Array out of bounds exceptions. Inline Assembly Wind supports inline assembly using the asm keyword. asm { mov eax, 10; add eax, 20; } You can also reference local variables in inline assembly. asm { mov eax, ?x; add eax, 0x10; } Happy coding with Wind! \ud83c\udf89","title":"Syntax"},{"location":"learn/syntax/#wind-syntax-reference","text":"Welcome to the Wind Language Syntax Reference! This page will guide you through the syntax of the Wind programming language, including its keywords, operators, and conventions.","title":"Wind syntax reference"},{"location":"learn/syntax/#comments","text":"Comments in Wind are similar to C-style comments and can be single-line or multi-line. // This is a single-line comment /* This is a multi-line comment */","title":"Comments"},{"location":"learn/syntax/#directives","text":"Let's break the ice with the @ directives. These are used to include files, define flags, and more.","title":"@ Directives"},{"location":"learn/syntax/#include","text":"The include directive is used to include a file in the current file. The file path is relative to the current file. @include \"path/to/file.w\" Using # as the first character of the file path will include a file from the standard library. @include \"#types.wi\" Multi include is also supported. @include [ \"path/to/file1.w\" \"path/to/file2.w\" ]","title":"include"},{"location":"learn/syntax/#import","text":"Pay attention to the import directive. @import \"#my_module\" You can use # prefix here as well to include a module from the WIND_PKGS_PATH . Import searches for a dir like this: name/ name.wi name.w The name.wi file is the interface file, and the name.w file is the implementation file. The interface file should contain the function prototypes, and the implementation file should contain the function definitions. Interface file example: func test_fn(x: int): int; Implementation file example: func test_fn(x: int): int { return x*(x+1); }","title":"import"},{"location":"learn/syntax/#pure","text":"The pure directive is used to define a function flag. @pure[stack expr] func foo() {} stack - Local variables usage won't be optimized. expr - Expressions aren't optimized. logue - No prologue and epilogue will be generated. stchk - No check for stack overflow and integer overflow will be generated.","title":"pure"},{"location":"learn/syntax/#extern","text":"The extern directive is used to define a function as an external function. @extern func foo();","title":"extern"},{"location":"learn/syntax/#pub","text":"The pub directive is used to define a function as public. While public directive is not required for including functions, it is used to share functions between objects when linking. @pub func foo() {}","title":"pub"},{"location":"learn/syntax/#type","text":"The type directive is used to define a type. @type my_type = unsigned byte;","title":"type"},{"location":"learn/syntax/#linkflag","text":"The linkflag directive is used to define an ld flag. @linkflag(\"-lm);","title":"linkflag"},{"location":"learn/syntax/#keywords","text":"Wind has no concept of reserved-identifiers, so you can use any keyword as an identifier if you wish. However, the following keywords are used in the language and should be avoided as identifiers: func var global return branch else loop continue break asm true false Null","title":"Keywords"},{"location":"learn/syntax/#data-types","text":"Wind has some primitive data types: byte = signed 8 bits short = signed 16 bits int = signed 32 bits long = signed 64 bits unsigned byte = unsigned 8 bits ... But the \"#types.wi\" std file provides some more types: s8 = signed 8 bits s16 = signed 16 bits s32 = signed 32 bits s64 = signed 64 bits u8 = unsigned 8 bits s16 = unsigned 16 bits s32 = unsigned 32 bits s64 = unsigned 64 bits bool = 8 bits char = 8 bits Arrays are declared using the following syntax: var arr: [int; 10];","title":"Data Types"},{"location":"learn/syntax/#pointers","text":"Pointers are declared using the following syntax: var ptr: ptr<int>; Wind convention is to use heap allocation over stack allocated arrays. with the guard![] directive, you can check for null pointers and prevent dereferencing. var my_ptr: ptr<char> = guard![malloc(32)];","title":"Pointers"},{"location":"learn/syntax/#casting","text":"Casting in Wind is done with the as operator. var x: ptr<u64> = malloc(...); (x as ptr<char>)[0]='x';","title":"Casting"},{"location":"learn/syntax/#sizeof","text":"The sizeof<> directive is used to get the (move) size of a type. var size_int: int = sizeof<int>;","title":"Sizeof"},{"location":"learn/syntax/#variables","text":"Variables in Wind are declared using the var keyword, followed by the variable name and type. var x: int = 10; You can declared them in bulk as well. var [x,y,z]: int = 0;","title":"Variables"},{"location":"learn/syntax/#global-variables","text":"Global variables are declared using the global keyword. global x: int = 10; Non declarable in bulk.","title":"Global Variables"},{"location":"learn/syntax/#functions","text":"Functions in Wind are declared using the func keyword, followed by the function name, parameters, and return type. func add(x: int, y: int): int { return x + y; } There's no wrapper for variadic functions, but you can still use ... for external C functions. @extern func printf(format: string, ...): int;","title":"Functions"},{"location":"learn/syntax/#namespaces","text":"Namespaces in Wind are declared using the namespace keyword. namespace my_namespace { func foo() { puts(\"Hello, World!\"); } } Used with the :: operator. my_namespace::foo();","title":"Namespaces"},{"location":"learn/syntax/#control-flow","text":"Wind has the usual control flow features with unique syntax.","title":"Control Flow"},{"location":"learn/syntax/#branch","text":"The branch keyword is used to define a conditional statement. branch [ x == 0: puts(\"x is zero\"); else: { puts(\"x != 0); return 1; } ]","title":"Branch"},{"location":"learn/syntax/#loop","text":"The loop keyword is used to define a loop statement. loop [x < 10] { puts(\"x is less than 10\"); x++; } There's no for loop in Wind, but you can use the loop keyword with a counter.","title":"Loop"},{"location":"learn/syntax/#continue","text":"The continue keyword is used to skip the current iteration of a loop. loop [x < 10] { x++; continue; }","title":"Continue"},{"location":"learn/syntax/#break","text":"The break keyword is used to exit a loop. loop [x < 10] { x++; break; }","title":"Break"},{"location":"learn/syntax/#try-catch","text":"Wind has a try-catch implementation for error handling. This is a simple implementation and is not as powerful as other languages. In fact it's just a wrapper to set the handler code for arithmetic exceptions and other security features like guard![] . try { T += 20_000; // sum overflow T = guard![Null]; } [SUM_OF] -> { printf(\"Sum overflow handled\\n\"); } [GUARD] -> { printf(\"Null pointer exception handled\\n\"); } finally { printf(\"Exceptions handled\\n\"); }","title":"Try Catch"},{"location":"learn/syntax/#exceptions","text":"SUM_OF - Arithmetic exceptions. SUB_OF - Arithmetic exceptions. MUL_OF - Arithmetic exceptions. DIV_OF - Arithmetic exceptions. GUARD - Null pointer exceptions. BOUNDS - Array out of bounds exceptions.","title":"Exceptions"},{"location":"learn/syntax/#inline-assembly","text":"Wind supports inline assembly using the asm keyword. asm { mov eax, 10; add eax, 20; } You can also reference local variables in inline assembly. asm { mov eax, ?x; add eax, 0x10; } Happy coding with Wind! \ud83c\udf89","title":"Inline Assembly"},{"location":"troubleshooting/runtime/","text":"Troubleshooting: ld: cannot find wrt.o: No such file or directory Issue: The error ld: cannot find wrt.o: No such file or directory occurs because Wind comes with a runtime that needs to be compiled within the compiler using CMake. This runtime is necessary for the successful linking of object files during the build process. Solution: To resolve this issue, you can either reinstall the compiler or manually compile the runtime yourself. Reinstall the Compiler : Reinstalling the compiler will ensure that the runtime is correctly included and compiled. Compile the Runtime Manually : If you're running Wind from source, compile the runtime by running the following command: wind src/runtime/stack.w src/runtime/handler.w src/runtime/start.w -ej -o RUNTIME_PATH Here, RUNTIME_PATH refers to the path where you want to output the compiled runtime. If you're running Wind from source, this will likely be src/runtime/wrt.o . Additional Information: Ensure that your CMake configuration includes the runtime during the build process. If you continue to encounter issues, double-check your environment paths and installation steps. Related Links: Wind Documentation Installation Guide","title":"Runtime"},{"location":"troubleshooting/runtime/#troubleshooting-ld-cannot-find-wrto-no-such-file-or-directory","text":"","title":"Troubleshooting: ld: cannot find wrt.o: No such file or directory"},{"location":"troubleshooting/runtime/#issue","text":"The error ld: cannot find wrt.o: No such file or directory occurs because Wind comes with a runtime that needs to be compiled within the compiler using CMake. This runtime is necessary for the successful linking of object files during the build process.","title":"Issue:"},{"location":"troubleshooting/runtime/#solution","text":"To resolve this issue, you can either reinstall the compiler or manually compile the runtime yourself. Reinstall the Compiler : Reinstalling the compiler will ensure that the runtime is correctly included and compiled. Compile the Runtime Manually : If you're running Wind from source, compile the runtime by running the following command: wind src/runtime/stack.w src/runtime/handler.w src/runtime/start.w -ej -o RUNTIME_PATH Here, RUNTIME_PATH refers to the path where you want to output the compiled runtime. If you're running Wind from source, this will likely be src/runtime/wrt.o .","title":"Solution:"},{"location":"troubleshooting/runtime/#additional-information","text":"Ensure that your CMake configuration includes the runtime during the build process. If you continue to encounter issues, double-check your environment paths and installation steps.","title":"Additional Information:"},{"location":"troubleshooting/runtime/#related-links","text":"Wind Documentation Installation Guide","title":"Related Links:"}]}